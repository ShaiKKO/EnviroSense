"""
Transformer vibration source implementation.

This module provides the specific vibration modeling for power transformers,
including different condition states and their characteristic frequencies.
"""

import numpy as np
from typing import Tuple, List, Dict, Optional, Any, Union
import math

from envirosense.core.physics.coordinates import Vector3D
from envirosense.core.physics.vibration.base import VibrationSource


class TransformerVibration(VibrationSource):
    """
    Models vibration patterns generated by power transformers.
    
    This class models the specific vibration characteristics of power transformers,
    including their fundamental frequencies (typically at twice the electrical 
    frequency) and harmonics, as well as different operating conditions.
    """
    
    # Operating condition constants
    CONDITION_NORMAL = "normal"
    CONDITION_OVERLOADED = "overloaded"
    CONDITION_LOOSE_COMPONENTS = "loose_components"
    CONDITION_OIL_FLOW_ISSUE = "oil_flow_issue"
    CONDITION_WINDING_ISSUE = "winding_issue"
    
    def __init__(self, 
                 name: str, 
                 position: Union[Vector3D, Tuple[float, float, float]],
                 power_rating: float = 1000e3,  # 1 MVA default
                 fundamental_freq: float = 120.0,  # Twice 60 Hz in North America
                 condition: str = CONDITION_NORMAL,
                 source_id: Optional[str] = None):
        """
        Initialize transformer vibration source.
        
        Args:
            name: Transformer name
            position: Position in 3D space
            power_rating: Power rating in VA
            fundamental_freq: Fundamental vibration frequency (typically 2x electrical frequency)
            condition: Operating condition of the transformer
            source_id: Optional unique identifier
        """
        super().__init__(name, position, source_id)
        
        self.power_rating = power_rating
        self.fundamental_freq = fundamental_freq
        self.condition = condition
        self.load_factor = 1.0  # Default to full load
        
        # Store additional parameters in metadata
        self.metadata.update({
            "power_rating": power_rating,
            "fundamental_freq": fundamental_freq,
            "condition": condition,
            "load_factor": self.load_factor
        })
    
    def set_load_factor(self, load_factor: float) -> None:
        """
        Set the current load factor (0.0 to 1.0+).
        
        Args:
            load_factor: Current load as fraction of rated capacity (1.0 = full load)
        """
        self.load_factor = max(0.0, load_factor)
        self.metadata["load_factor"] = self.load_factor
    
    def set_condition(self, condition: str) -> None:
        """
        Set the operating condition.
        
        Args:
            condition: One of the CONDITION_* constants
        """
        self.condition = condition
        self.metadata["condition"] = condition
    
    def _get_harmonics(self) -> Dict[float, float]:
        """
        Get harmonic frequencies and their relative amplitudes.
        
        Different operating conditions have different harmonic patterns.
        
        Returns:
            Dictionary mapping frequency multipliers to relative amplitudes
        """
        # Base harmonics present in all transformers
        # Keys are multiples of fundamental frequency, values are relative amplitudes
        harmonics = {
            1.0: 1.0,    # Fundamental (e.g., 120 Hz)
            2.0: 0.5,    # 1st harmonic (e.g., 240 Hz)
            3.0: 0.3,    # 2nd harmonic
            4.0: 0.2,    # 3rd harmonic
            5.0: 0.1,    # 4th harmonic
            6.0: 0.05    # 5th harmonic
        }
        
        # Modify harmonics based on condition
        if self.condition == self.CONDITION_OVERLOADED:
            # Overloaded transformers have stronger core saturation harmonics
            harmonics[2.0] = 0.8
            harmonics[4.0] = 0.5
            harmonics[6.0] = 0.3
            # Add additional high-frequency components
            harmonics[8.0] = 0.25
            harmonics[10.0] = 0.2
            
        elif self.condition == self.CONDITION_LOOSE_COMPONENTS:
            # Loose components create rattling and more broadband noise
            harmonics[1.0] = 0.9  # Slightly reduced fundamental
            # Add rattling frequencies (non-integer harmonics)
            harmonics[1.5] = 0.4
            harmonics[2.3] = 0.35
            harmonics[3.7] = 0.3
            # More high-frequency components
            harmonics[7.0] = 0.25
            harmonics[9.0] = 0.2
            
        elif self.condition == self.CONDITION_OIL_FLOW_ISSUE:
            # Oil flow issues create distinctive patterns
            harmonics[1.0] = 0.8  # Reduced fundamental
            # Add characteristic oil flow frequencies
            harmonics[1.3] = 0.6  # Prominent oil flow frequency
            harmonics[2.7] = 0.4
            # More broadband noise across spectrum
            for i in range(3, 12):
                if i not in harmonics:
                    harmonics[i] = 0.1
                    
        elif self.condition == self.CONDITION_WINDING_ISSUE:
            # Winding issues create more high-frequency vibrations
            harmonics[1.0] = 0.7  # Significantly reduced fundamental
            # Strong high-frequency components characteristic of winding issues
            harmonics[3.0] = 0.6
            harmonics[5.0] = 0.5
            harmonics[7.0] = 0.4
            harmonics[9.0] = 0.3
        
        # Scale harmonics based on load factor
        # Higher loads produce stronger vibrations, with remapped relationship
        # (vibration amplitude ∝ load² for many frequencies)
        load_scale = self.load_factor ** 2
        for freq in harmonics:
            if freq == 1.0:
                # Fundamental frequency scales directly with load factor
                harmonics[freq] *= self.load_factor
            else:
                # Harmonics typically increase non-linearly with load
                harmonics[freq] *= load_scale
                
        return harmonics

    def _calculate_base_amplitude(self) -> float:
        """
        Calculate the base amplitude based on transformer size.
        
        Returns:
            Base vibration amplitude in m/s²
        """
        # Base amplitude scales with power rating (larger transformers vibrate more)
        # but not linearly (sqrt relationship as a simplified model)
        # Normalize to 1 MVA
        power_factor = math.sqrt(self.power_rating / 1e6)
        
        # Base amplitude for a 1 MVA transformer at full load
        base_amp = 0.05  # m/s²
        
        return base_amp * power_factor
    
    def generate_spectrum(self, freq_range: Tuple[float, float, int]) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate frequency spectrum for this transformer.
        
        Args:
            freq_range: Tuple of (min_freq, max_freq, num_points)
            
        Returns:
            Tuple of (frequencies, amplitudes) arrays
        """
        min_freq, max_freq, num_points = freq_range
        
        # Generate frequency array
        frequencies = np.linspace(min_freq, max_freq, num_points)
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Get harmonics
        harmonics = self._get_harmonics()
        
        # Initialize amplitudes array
        amplitudes = np.zeros_like(frequencies)
        
        # For each harmonic, add a peak at the corresponding frequency
        for harmonic_factor, relative_amp in harmonics.items():
            harmonic_freq = self.fundamental_freq * harmonic_factor
            
            # Skip if outside frequency range
            if harmonic_freq < min_freq or harmonic_freq > max_freq:
                continue
            
            # Create a peak around the harmonic frequency
            peak_width = 0.05 * harmonic_freq  # Width of peak proportional to frequency
            
            # Calculate distance of all frequency points from this harmonic
            dist_from_harmonic = np.abs(frequencies - harmonic_freq)
            
            # Create Gaussian-like peak around the harmonic
            peak = base_amplitude * relative_amp * np.exp(-(dist_from_harmonic / peak_width) ** 2)
            
            # Add to total amplitude
            amplitudes += peak
        
        # Add ambient noise floor (white noise)
        noise_level = 0.001  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 2  # More noise in abnormal conditions
        
        noise = noise_level * np.random.random(len(frequencies))
        amplitudes += noise
        
        return frequencies, amplitudes
    
    def generate_time_signal(self, duration: float, sample_rate: Optional[float] = None) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate time-domain signal for this transformer.
        
        Args:
            duration: Signal duration in seconds
            sample_rate: Sample rate in Hz, defaults to 10x max expected frequency
            
        Returns:
            Tuple of (time_points, amplitude) arrays
        """
        # If no sample rate provided, use 10x the highest expected frequency
        if sample_rate is None:
            # Use 10x the highest harmonic (assume 10th harmonic is highest)
            sample_rate = 10 * self.fundamental_freq * 10
        
        # Generate time points
        num_samples = int(duration * sample_rate)
        time_points = np.linspace(0, duration, num_samples)
        
        # Get harmonics
        harmonics = self._get_harmonics()
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Initialize signal
        signal = np.zeros_like(time_points)
        
        # Add each harmonic component to the signal
        for harmonic_factor, relative_amp in harmonics.items():
            harmonic_freq = self.fundamental_freq * harmonic_factor
            
            # Component amplitude
            component_amp = base_amplitude * relative_amp
            
            # Generate component signal (sine wave)
            # Add random phase shift for realism
            phase_shift = 2 * np.pi * np.random.random()
            component = component_amp * np.sin(2 * np.pi * harmonic_freq * time_points + phase_shift)
            
            # Add to total signal
            signal += component
        
        # Add ambient noise
        noise_level = 0.005 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 2  # More noise in abnormal conditions
        
        noise = noise_level * np.random.normal(0, 1, len(time_points))
        signal += noise
        
        return time_points, signal
