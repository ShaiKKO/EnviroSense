"""
Compressor vibration source implementation.

This module provides the specific vibration modeling for air compressors,
including different types, condition states, and their characteristic frequencies.
"""

import numpy as np
from typing import Tuple, List, Dict, Optional, Any, Union
import math

from envirosense.core.physics.coordinates import Vector3D
from envirosense.core.physics.vibration.base import VibrationSource


class CompressorVibration(VibrationSource):
    """
    Models vibration patterns generated by air compressors.
    
    This class models the specific vibration characteristics of different types of
    compressors, including their fundamental frequencies and harmonics based on 
    operating parameters, as well as different operating conditions.
    """
    
    # Operating condition constants
    CONDITION_NORMAL = "normal"
    CONDITION_UNBALANCED = "unbalanced"
    CONDITION_BEARING_FAULT = "bearing_fault"
    CONDITION_VALVE_LEAK = "valve_leak"
    CONDITION_LOOSE_MOUNTING = "loose_mounting"
    
    # Compressor type constants
    TYPE_ROTARY_SCREW = "rotary_screw"
    TYPE_RECIPROCATING = "reciprocating"
    TYPE_CENTRIFUGAL = "centrifugal"
    TYPE_SCROLL = "scroll"
    
    def __init__(self, 
                 name: str, 
                 position: Union[Vector3D, Tuple[float, float, float]],
                 power_rating: float = 50e3,  # 50 kW default
                 rotation_speed: float = 1800.0,  # RPM
                 comp_type: str = TYPE_ROTARY_SCREW,
                 condition: str = CONDITION_NORMAL,
                 source_id: Optional[str] = None):
        """
        Initialize compressor vibration source.
        
        Args:
            name: Compressor name
            position: Position in 3D space
            power_rating: Power rating in watts
            rotation_speed: Primary rotation speed in RPM
            comp_type: Compressor type (rotary_screw, reciprocating, etc.)
            condition: Operating condition of the compressor
            source_id: Optional unique identifier
        """
        super().__init__(name, position, source_id)
        
        self.power_rating = power_rating
        self.rotation_speed = rotation_speed
        self.comp_type = comp_type
        self.condition = condition
        self.load_factor = 1.0  # Default to full load
        
        # Calculate fundamental frequency (rotation frequency)
        self.rotation_freq = rotation_speed / 60.0  # Hz
        
        # Based on compressor type, set additional parameters
        self._set_type_parameters()
        
        # Store additional parameters in metadata
        self.metadata.update({
            "power_rating": power_rating,
            "rotation_speed": rotation_speed,
            "rotation_freq": self.rotation_freq,
            "comp_type": comp_type,
            "condition": condition,
            "load_factor": self.load_factor
        })
    
    def _set_type_parameters(self) -> None:
        """
        Set parameters specific to the compressor type.
        """
        if self.comp_type == self.TYPE_ROTARY_SCREW:
            # Rotary screw compressors typically have male/female rotors
            self.num_lobes = 6  # Typical for male rotor
            self.lobe_pass_freq = self.rotation_freq * self.num_lobes
            self.metadata["num_lobes"] = self.num_lobes
            self.metadata["lobe_pass_freq"] = self.lobe_pass_freq
            
        elif self.comp_type == self.TYPE_RECIPROCATING:
            # Reciprocating compressors have cylinders/pistons
            # Power determines number of cylinders (simplified model)
            if self.power_rating < 20e3:
                self.num_cylinders = 2
            elif self.power_rating < 100e3:
                self.num_cylinders = 4
            else:
                self.num_cylinders = 6
                
            # For 4-stroke cycle, each cylinder fires once every 2 rotations
            self.compression_freq = self.rotation_freq * self.num_cylinders / 2
            self.metadata["num_cylinders"] = self.num_cylinders
            self.metadata["compression_freq"] = self.compression_freq
            
        elif self.comp_type == self.TYPE_CENTRIFUGAL:
            # Centrifugal compressors have impellers with blades
            # Estimate number of impeller blades based on size
            if self.power_rating < 500e3:
                self.num_blades = 12
            else:
                self.num_blades = 16
                
            self.blade_pass_freq = self.rotation_freq * self.num_blades
            self.metadata["num_blades"] = self.num_blades
            self.metadata["blade_pass_freq"] = self.blade_pass_freq
            
        elif self.comp_type == self.TYPE_SCROLL:
            # Scroll compressors have orbital motion
            self.orbital_freq = self.rotation_freq  # Same as rotation frequency
            # Number of scroll wraps affects harmonic content
            self.num_wraps = 3  # Typical value
            self.metadata["orbital_freq"] = self.orbital_freq
            self.metadata["num_wraps"] = self.num_wraps
    
    def set_load_factor(self, load_factor: float) -> None:
        """
        Set the current load factor (0.0 to 1.0+).
        
        Args:
            load_factor: Current load as fraction of rated capacity (1.0 = full load)
        """
        self.load_factor = max(0.0, load_factor)
        self.metadata["load_factor"] = self.load_factor
    
    def set_condition(self, condition: str) -> None:
        """
        Set the operating condition.
        
        Args:
            condition: One of the CONDITION_* constants
        """
        self.condition = condition
        self.metadata["condition"] = condition
    
    def set_rotation_speed(self, rpm: float) -> None:
        """
        Set the rotation speed in RPM.
        
        Args:
            rpm: Speed in revolutions per minute
        """
        self.rotation_speed = rpm
        self.rotation_freq = rpm / 60.0  # Hz
        
        # Update dependent parameters
        self._set_type_parameters()
        
        # Update metadata
        self.metadata["rotation_speed"] = rpm
        self.metadata["rotation_freq"] = self.rotation_freq
    
    def _get_frequency_components(self) -> Dict[float, float]:
        """
        Get frequency components and their relative amplitudes.
        
        Different compressor types and conditions have different frequency patterns.
        
        Returns:
            Dictionary mapping frequency in Hz to relative amplitudes
        """
        # Base components present in all compressors
        components = {
            self.rotation_freq: 1.0,              # 1x rotation frequency
            2 * self.rotation_freq: 0.5,          # 2x rotation frequency
            3 * self.rotation_freq: 0.2,          # 3x rotation frequency
            4 * self.rotation_freq: 0.1           # 4x rotation frequency
        }
        
        # Add components based on compressor type
        if self.comp_type == self.TYPE_ROTARY_SCREW:
            # Lobe pass frequency is dominant
            components[self.lobe_pass_freq] = 1.5
            components[2 * self.lobe_pass_freq] = 0.8
            components[3 * self.lobe_pass_freq] = 0.4
            
            # Add rotor interactions - sidebands
            components[self.lobe_pass_freq - self.rotation_freq] = 0.3
            components[self.lobe_pass_freq + self.rotation_freq] = 0.3
            
        elif self.comp_type == self.TYPE_RECIPROCATING:
            # Compression frequency is dominant
            components[self.compression_freq] = 1.8
            components[2 * self.compression_freq] = 1.0
            components[3 * self.compression_freq] = 0.6
            
            # Add valve frequencies
            # Valve impacts occur at twice compression frequency
            valve_freq = 2 * self.compression_freq
            components[valve_freq] = 1.2
            
            # Piston slap and rod dynamics
            for i in range(1, self.num_cylinders + 1):
                # Each cylinder has slightly different dynamics
                cyl_freq = i * self.rotation_freq / self.num_cylinders
                components[cyl_freq] = 0.3
            
        elif self.comp_type == self.TYPE_CENTRIFUGAL:
            # Blade pass frequency is dominant
            components[self.blade_pass_freq] = 1.3
            components[2 * self.blade_pass_freq] = 0.6
            
            # Aerodynamic effects
            flow_turbulence_freq = self.blade_pass_freq * 0.7
            components[flow_turbulence_freq] = 0.4
            
            # Higher harmonics of rotation frequency due to high speed
            for i in range(5, 10):
                components[i * self.rotation_freq] = 0.1 / i
            
        elif self.comp_type == self.TYPE_SCROLL:
            # Orbital frequency and harmonics
            components[self.orbital_freq] = 1.2
            
            # Scroll wrap interaction frequencies
            wrap_freq = self.orbital_freq * self.num_wraps
            components[wrap_freq] = 0.9
            components[2 * wrap_freq] = 0.5
            
            # Scroll tip interaction
            tip_freq = self.orbital_freq * 2 * self.num_wraps
            components[tip_freq] = 0.7
        
        # Modify components based on condition
        if self.condition == self.CONDITION_UNBALANCED:
            # Unbalanced rotors show strong 1x component
            components[self.rotation_freq] = 2.0
            
            # Add modulation to other frequencies
            for freq in list(components.keys()):
                if freq != self.rotation_freq:
                    # Add sidebands to major frequencies
                    components[freq - self.rotation_freq] = components[freq] * 0.3
                    components[freq + self.rotation_freq] = components[freq] * 0.3
            
        elif self.condition == self.CONDITION_BEARING_FAULT:
            # Bearing defect frequencies (simplified model)
            bearing_defect_freq = 4.7 * self.rotation_freq  # BPFO simplified
            
            # Add bearing fault frequencies
            components[bearing_defect_freq] = 0.8
            components[2 * bearing_defect_freq] = 0.5
            
            # Add high-frequency energy typical of bearing faults
            for freq in np.linspace(5000, 8000, 10):
                components[freq] = 0.1
            
        elif self.condition == self.CONDITION_VALVE_LEAK:
            if self.comp_type == self.TYPE_RECIPROCATING:
                # Valve leaks in reciprocating compressors cause distinctive patterns
                components[self.compression_freq] *= 0.7  # Reduced compression efficiency
                
                # Add turbulent flow frequency components
                leak_base_freq = 3 * self.compression_freq
                for i in range(1, 5):
                    # Create leak noise "clusters" around harmonics
                    leak_freq = leak_base_freq * i * (1 + 0.05 * np.random.random())
                    components[leak_freq] = 0.6 / i
            else:
                # For other compressor types, add broadband noise
                for freq in np.linspace(1000, 5000, 20):
                    components[freq] = 0.05 + 0.05 * np.random.random()
            
        elif self.condition == self.CONDITION_LOOSE_MOUNTING:
            # Loose mountings create subharmonics and increased amplitudes
            components[self.rotation_freq / 2] = 0.5
            components[self.rotation_freq / 3] = 0.3
            
            # Increased amplitude at base frequencies
            components[self.rotation_freq] *= 1.5
            components[2 * self.rotation_freq] *= 1.8
            
            # Create more random frequency content
            for freq in np.linspace(100, 1000, 15):
                components[freq] = 0.2 * np.random.random()
        
        # Scale components based on load factor
        # Higher loads produce stronger vibrations but in different ways
        for freq in list(components.keys()):
            if freq == self.rotation_freq:
                # Fundamental frequency typically has minimum at mid-load
                # This creates a "U" shaped curve with higher amplitude at low and high loads
                load_scale = 0.8 + 0.2 * (2 * (self.load_factor - 0.5)**2)
                components[freq] *= load_scale
            elif freq < 1000:  # Low frequencies
                # Low frequencies tend to increase with load
                components[freq] *= (0.7 + 0.3 * self.load_factor)
            else:  # High frequencies
                # High frequencies can actually decrease at higher loads due to damping
                components[freq] *= (1.0 - 0.3 * self.load_factor)
        
        return components
    
    def _calculate_base_amplitude(self) -> float:
        """
        Calculate the base amplitude based on compressor size and type.
        
        Returns:
            Base vibration amplitude in m/s²
        """
        # Base amplitude scales with power rating (larger compressors vibrate more)
        # but not linearly (sqrt relationship as a simplified model)
        # Normalize to 50 kW
        power_factor = math.sqrt(self.power_rating / 50e3)
        
        # Base amplitude varies by compressor type
        if self.comp_type == self.TYPE_ROTARY_SCREW:
            base_amp = 0.12  # m/s²
        elif self.comp_type == self.TYPE_RECIPROCATING:
            base_amp = 0.25  # Reciprocating compressors vibrate more
        elif self.comp_type == self.TYPE_CENTRIFUGAL:
            base_amp = 0.08  # Centrifugal compressors tend to be smoother
        else:  # Scroll
            base_amp = 0.10
        
        # Rotation speed effect
        speed_factor = (self.rotation_speed / 1800.0)**1.5
        
        return base_amp * power_factor * speed_factor
    
    def generate_spectrum(self, freq_range: Tuple[float, float, int]) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate frequency spectrum for this compressor.
        
        Args:
            freq_range: Tuple of (min_freq, max_freq, num_points)
            
        Returns:
            Tuple of (frequencies, amplitudes) arrays
        """
        min_freq, max_freq, num_points = freq_range
        
        # Generate frequency array
        frequencies = np.linspace(min_freq, max_freq, num_points)
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Initialize amplitudes array
        amplitudes = np.zeros_like(frequencies)
        
        # For each component, add a peak at the corresponding frequency
        for component_freq, relative_amp in components.items():
            # Skip if outside frequency range
            if component_freq < min_freq or component_freq > max_freq:
                continue
            
            # Create a peak around the component frequency
            peak_width = 0.03 * component_freq  # Width of peak proportional to frequency
            
            # Calculate distance of all frequency points from this component
            dist_from_component = np.abs(frequencies - component_freq)
            
            # Create Gaussian-like peak around the component
            peak = base_amplitude * relative_amp * np.exp(-(dist_from_component / peak_width) ** 2)
            
            # Add to total amplitude
            amplitudes += peak
        
        # Add ambient noise floor (white noise)
        noise_level = 0.005 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 3  # More noise in abnormal conditions
        
        # Add some random variations to make the spectrum more realistic
        if self.comp_type == self.TYPE_RECIPROCATING:
            # Reciprocating compressors have more broadband noise
            for i in range(10):
                noise_freq = min_freq + (max_freq - min_freq) * np.random.random()
                noise_width = 50 + 200 * np.random.random()  # Hz
                dist_from_noise = np.abs(frequencies - noise_freq)
                noise_peak = 0.1 * base_amplitude * np.exp(-(dist_from_noise / noise_width) ** 2)
                amplitudes += noise_peak
        
        # Add broadband noise
        noise = noise_level * np.random.random(len(frequencies))
        amplitudes += noise
        
        return frequencies, amplitudes
    
    def generate_time_signal(self, duration: float, sample_rate: Optional[float] = None) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate time-domain signal for this compressor.
        
        Args:
            duration: Signal duration in seconds
            sample_rate: Sample rate in Hz, defaults to 10x max expected frequency
            
        Returns:
            Tuple of (time_points, amplitude) arrays
        """
        # If no sample rate provided, calculate based on compressor type
        if sample_rate is None:
            if self.comp_type == self.TYPE_RECIPROCATING:
                # Need higher sample rate for impulsive content
                sample_rate = 20000
            elif self.comp_type == self.TYPE_CENTRIFUGAL:
                # Need higher sample rate for high-frequency blade pass
                sample_rate = max(20000, 10 * self.blade_pass_freq)
            else:
                # Default sample rate
                sample_rate = 10000
        
        # Generate time points
        num_samples = int(duration * sample_rate)
        time_points = np.linspace(0, duration, num_samples)
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Initialize signal
        signal = np.zeros_like(time_points)
        
        # Add each frequency component to the signal
        for component_freq, relative_amp in components.items():
            # Skip frequencies above Nyquist frequency
            if component_freq > sample_rate / 2:
                continue
                
            # Component amplitude
            component_amp = base_amplitude * relative_amp
            
            # Generate component signal (sine wave)
            # Add random phase shift for realism
            phase_shift = 2 * np.pi * np.random.random()
            component = component_amp * np.sin(2 * np.pi * component_freq * time_points + phase_shift)
            
            # Add to total signal
            signal += component
        
        # Add special characteristics based on compressor type and condition
        if self.comp_type == self.TYPE_RECIPROCATING:
            # Add impulsive content from valve actions
            # This creates periodic impacts at the compression frequency
            impact_interval = 1.0 / self.compression_freq
            impact_strength = 0.8 * base_amplitude
            
            for t in np.arange(0, duration, impact_interval):
                # Find closest time point
                idx = int(t * sample_rate)
                if idx < len(signal):
                    # Add an exponentially decaying impulse
                    decay_time = 0.005  # seconds
                    
                    # Time points relative to impact
                    rel_time = time_points[idx:] - time_points[idx]
                    
                    # Create decaying impulse
                    decay = impact_strength * np.exp(-rel_time / decay_time)
                    
                    # Add to signal, limited to len(signal)
                    max_len = min(len(decay), len(signal) - idx)
                    signal[idx:idx + max_len] += decay[:max_len]
            
            # Add modulations based on crankshaft rotation
            mod_freq = self.rotation_freq
            mod_depth = 0.2
            modulation = 1 + mod_depth * np.sin(2 * np.pi * mod_freq * time_points)
            signal *= modulation
        
        # Add valve leak effects if applicable
        if self.condition == self.CONDITION_VALVE_LEAK and self.comp_type == self.TYPE_RECIPROCATING:
            # Add high-frequency noise bursts at compression points
            for t in np.arange(0, duration, impact_interval):
                # Find closest time point
                idx = int(t * sample_rate)
                if idx < len(signal):
                    # Duration of leak noise
                    leak_duration = 0.02  # seconds
                    leak_samples = int(leak_duration * sample_rate)
                    end_idx = min(idx + leak_samples, len(signal))
                    
                    # Generate leak noise (filtered random)
                    leak_noise = 0.4 * base_amplitude * np.random.normal(0, 1, end_idx - idx)
                    
                    # Apply envelope
                    envelope = np.exp(-np.linspace(0, 5, end_idx - idx))
                    leak_noise *= envelope
                    
                    # Add to signal
                    signal[idx:end_idx] += leak_noise
        
        # Add ambient noise
        noise_level = 0.01 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 2  # More noise in abnormal conditions
        
        noise = noise_level * np.random.normal(0, 1, len(time_points))
        signal += noise
        
        return time_points, signal
