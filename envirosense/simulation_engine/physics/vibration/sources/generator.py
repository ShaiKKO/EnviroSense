"""
Generator vibration source implementation.

This module provides the specific vibration modeling for generators,
including different condition states and their characteristic frequencies.
"""

import numpy as np
from typing import Tuple, List, Dict, Optional, Any, Union
import math

from envirosense.core.physics.coordinates import Vector3D
from envirosense.core.physics.vibration.base import VibrationSource


class GeneratorVibration(VibrationSource):
    """
    Models vibration patterns generated by power generators.
    
    This class models the specific vibration characteristics of generators,
    including their fundamental frequencies and harmonics based on RPM, as
    well as different operating conditions and fuel types.
    """
    
    # Operating condition constants
    CONDITION_NORMAL = "normal"
    CONDITION_UNBALANCED = "unbalanced"
    CONDITION_MISALIGNED = "misaligned"
    CONDITION_BEARING_ISSUE = "bearing_issue"
    CONDITION_FUEL_SYSTEM = "fuel_system_issue"
    
    # Fuel type constants
    FUEL_DIESEL = "diesel"
    FUEL_NATURAL_GAS = "natural_gas"
    FUEL_GASOLINE = "gasoline"
    
    def __init__(self, 
                 name: str, 
                 position: Union[Vector3D, Tuple[float, float, float]],
                 power_rating: float = 100e3,  # 100 kVA default
                 rpm: float = 1800.0,  # Typical 4-pole generator speed (60 Hz)
                 fuel_type: str = FUEL_DIESEL,
                 condition: str = CONDITION_NORMAL,
                 source_id: Optional[str] = None):
        """
        Initialize generator vibration source.
        
        Args:
            name: Generator name
            position: Position in 3D space
            power_rating: Power rating in VA
            rpm: Generator speed in revolutions per minute
            fuel_type: Type of fuel used
            condition: Operating condition of the generator
            source_id: Optional unique identifier
        """
        super().__init__(name, position, source_id)
        
        self.power_rating = power_rating
        self.rpm = rpm
        self.fuel_type = fuel_type
        self.condition = condition
        self.load_factor = 1.0  # Default to full load
        
        # Calculate fundamental frequency (rotation frequency)
        self.rotation_freq = rpm / 60.0  # Hz
        
        # Number of cylinders (typical for diesel generators)
        if fuel_type == self.FUEL_DIESEL:
            self.num_cylinders = 6 if power_rating > 200e3 else 4
        elif fuel_type == self.FUEL_NATURAL_GAS:
            self.num_cylinders = 8 if power_rating > 200e3 else 6
        else:  # Gasoline
            self.num_cylinders = 4
            
        # Calculate firing frequency
        # For 4-stroke engines, cylinder fires once every 2 rotations
        self.firing_freq = self.rotation_freq * self.num_cylinders / 2
        
        # Store additional parameters in metadata
        self.metadata.update({
            "power_rating": power_rating,
            "rpm": rpm,
            "rotation_freq": self.rotation_freq,
            "fuel_type": fuel_type,
            "num_cylinders": self.num_cylinders,
            "firing_freq": self.firing_freq,
            "condition": condition,
            "load_factor": self.load_factor
        })
    
    def set_load_factor(self, load_factor: float) -> None:
        """
        Set the current load factor (0.0 to 1.0+).
        
        Args:
            load_factor: Current load as fraction of rated capacity (1.0 = full load)
        """
        self.load_factor = max(0.0, load_factor)
        self.metadata["load_factor"] = self.load_factor
    
    def set_condition(self, condition: str) -> None:
        """
        Set the operating condition.
        
        Args:
            condition: One of the CONDITION_* constants
        """
        self.condition = condition
        self.metadata["condition"] = condition
    
    def set_rpm(self, rpm: float) -> None:
        """
        Set the generator speed in RPM.
        
        Args:
            rpm: Speed in revolutions per minute
        """
        self.rpm = rpm
        self.rotation_freq = rpm / 60.0  # Hz
        self.firing_freq = self.rotation_freq * self.num_cylinders / 2
        
        self.metadata["rpm"] = rpm
        self.metadata["rotation_freq"] = self.rotation_freq
        self.metadata["firing_freq"] = self.firing_freq
    
    def _get_frequency_components(self) -> Dict[float, float]:
        """
        Get frequency components and their relative amplitudes.
        
        Different operating conditions and fuel types have different frequency patterns.
        
        Returns:
            Dictionary mapping frequency in Hz to relative amplitudes
        """
        # Base components present in all generators
        components = {
            self.rotation_freq: 1.0,                  # 1x rotation frequency
            2 * self.rotation_freq: 0.5,              # 2x rotation frequency
            self.firing_freq: 0.8,                    # Firing frequency
            2 * self.firing_freq: 0.4,                # 2x firing frequency
            self.num_cylinders * self.rotation_freq: 0.3  # Cylinder count * rotation frequency
        }
        
        # Add components based on fuel type
        if self.fuel_type == self.FUEL_DIESEL:
            # Diesel engines have higher compression and more distinct firing impulses
            components[self.firing_freq] = 1.2
            components[2 * self.firing_freq] = 0.7
            components[3 * self.firing_freq] = 0.4
            
            # Add higher harmonics of firing frequency
            for i in range(4, 8):
                components[i * self.firing_freq] = 0.2 / i
            
        elif self.fuel_type == self.FUEL_NATURAL_GAS:
            # Natural gas engines have smoother running characteristics
            components[self.firing_freq] = 0.7
            components[2 * self.firing_freq] = 0.4
            components[3 * self.firing_freq] = 0.2
            
            # Add higher harmonics with less amplitude
            for i in range(4, 8):
                components[i * self.firing_freq] = 0.1 / i
                
        elif self.fuel_type == self.FUEL_GASOLINE:
            # Gasoline engines have characteristics between diesel and natural gas
            components[self.firing_freq] = 0.9
            components[2 * self.firing_freq] = 0.5
            components[3 * self.firing_freq] = 0.3
            
            # Add higher harmonics
            for i in range(4, 8):
                components[i * self.firing_freq] = 0.15 / i
        
        # Modify components based on condition
        if self.condition == self.CONDITION_UNBALANCED:
            # Unbalanced rotors show strong 1x component
            components[self.rotation_freq] = 2.0
            
            # Add sidebands around firing frequency
            components[self.firing_freq - self.rotation_freq] = 0.4
            components[self.firing_freq + self.rotation_freq] = 0.4
            
        elif self.condition == self.CONDITION_MISALIGNED:
            # Misalignment typically shows up at 2x rotation frequency
            components[2 * self.rotation_freq] = 1.5
            components[3 * self.rotation_freq] = 0.8
            
        elif self.condition == self.CONDITION_BEARING_ISSUE:
            # Bearing issues create high-frequency components
            bearing_defect_freq = 7.5 * self.rotation_freq  # Simplified model
            components[bearing_defect_freq] = 0.6
            components[2 * bearing_defect_freq] = 0.4
            
            # Add sidebands
            components[bearing_defect_freq - self.rotation_freq] = 0.3
            components[bearing_defect_freq + self.rotation_freq] = 0.3
            
        elif self.condition == self.CONDITION_FUEL_SYSTEM:
            # Fuel system issues affect firing frequency and create irregular combustion
            components[self.firing_freq] *= 0.7  # Reduced firing frequency amplitude
            
            # Add irregular firing components
            for cylinder in range(1, self.num_cylinders + 1):
                # Create frequency for each cylinder with slight variation
                cyl_freq = self.rotation_freq * cylinder / 2
                components[cyl_freq] = 0.4
                
                # Add misfiring component
                misfire_freq = cyl_freq * (1 + 0.05 * np.random.random())
                components[misfire_freq] = 0.3
        
        # Scale components based on load factor
        # Higher loads produce stronger vibrations
        for freq in list(components.keys()):
            # Core rotation frequencies scale with load factor
            if freq in [self.rotation_freq, 2 * self.rotation_freq]:
                components[freq] *= (0.6 + 0.4 * self.load_factor)
            # Firing frequencies scale more with load
            elif freq in [self.firing_freq, 2 * self.firing_freq]:
                components[freq] *= (0.3 + 0.7 * self.load_factor**2)
            # Other components scale linearly with load
            else:
                components[freq] *= (0.5 + 0.5 * self.load_factor)
        
        return components
    
    def _calculate_base_amplitude(self) -> float:
        """
        Calculate the base amplitude based on generator size and fuel type.
        
        Returns:
            Base vibration amplitude in m/s²
        """
        # Base amplitude scales with power rating (larger generators vibrate more)
        # but not linearly (sqrt relationship as a simplified model)
        # Normalize to 100 kVA
        power_factor = math.sqrt(self.power_rating / 100e3)
        
        # Base amplitude for a 100 kVA generator at full load
        base_amp = 0.15  # m/s²
        
        # Adjust based on fuel type (diesel engines typically vibrate more)
        if self.fuel_type == self.FUEL_DIESEL:
            fuel_factor = 1.5
        elif self.fuel_type == self.FUEL_NATURAL_GAS:
            fuel_factor = 0.8
        else:  # Gasoline
            fuel_factor = 1.2
        
        # Generators tend to vibrate more at higher speeds
        rpm_factor = self.rpm / 1800.0
        
        return base_amp * power_factor * fuel_factor * rpm_factor
    
    def generate_spectrum(self, freq_range: Tuple[float, float, int]) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate frequency spectrum for this generator.
        
        Args:
            freq_range: Tuple of (min_freq, max_freq, num_points)
            
        Returns:
            Tuple of (frequencies, amplitudes) arrays
        """
        min_freq, max_freq, num_points = freq_range
        
        # Generate frequency array
        frequencies = np.linspace(min_freq, max_freq, num_points)
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Initialize amplitudes array
        amplitudes = np.zeros_like(frequencies)
        
        # For each component, add a peak at the corresponding frequency
        for component_freq, relative_amp in components.items():
            # Skip if outside frequency range
            if component_freq < min_freq or component_freq > max_freq:
                continue
            
            # Create a peak around the component frequency
            peak_width = 0.03 * component_freq  # Width of peak proportional to frequency
            
            # Calculate distance of all frequency points from this component
            dist_from_component = np.abs(frequencies - component_freq)
            
            # Create Gaussian-like peak around the component
            peak = base_amplitude * relative_amp * np.exp(-(dist_from_component / peak_width) ** 2)
            
            # Add to total amplitude
            amplitudes += peak
        
        # Add ambient noise floor (white noise)
        noise_level = 0.003 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 3  # More noise in abnormal conditions
            
            # Additional random peaks for abnormal conditions
            num_peaks = 5
            for _ in range(num_peaks):
                peak_freq = min_freq + (max_freq - min_freq) * np.random.random()
                peak_width = 0.02 * peak_freq
                dist_from_peak = np.abs(frequencies - peak_freq)
                peak = 0.1 * base_amplitude * np.exp(-(dist_from_peak / peak_width) ** 2)
                amplitudes += peak
        
        # Add broadband noise
        noise = noise_level * np.random.random(len(frequencies))
        amplitudes += noise
        
        return frequencies, amplitudes
    
    def generate_time_signal(self, duration: float, sample_rate: Optional[float] = None) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate time-domain signal for this generator.
        
        Args:
            duration: Signal duration in seconds
            sample_rate: Sample rate in Hz, defaults to 10x max expected frequency
            
        Returns:
            Tuple of (time_points, amplitude) arrays
        """
        # If no sample rate provided, use 10x the highest expected frequency
        if sample_rate is None:
            # Use 10x a reasonable max frequency (8x firing frequency should capture most harmonics)
            sample_rate = 10 * 8 * self.firing_freq
        
        # Ensure sample rate is at least 10 kHz for good resolution
        sample_rate = max(10000, sample_rate)
        
        # Generate time points
        num_samples = int(duration * sample_rate)
        time_points = np.linspace(0, duration, num_samples)
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Initialize signal
        signal = np.zeros_like(time_points)
        
        # Add each frequency component to the signal
        for component_freq, relative_amp in components.items():
            # Skip frequencies above Nyquist frequency
            if component_freq > sample_rate / 2:
                continue
                
            # Component amplitude
            component_amp = base_amplitude * relative_amp
            
            # Generate component signal (sine wave)
            # Add random phase shift for realism
            phase_shift = 2 * np.pi * np.random.random()
            component = component_amp * np.sin(2 * np.pi * component_freq * time_points + phase_shift)
            
            # Add to total signal
            signal += component
        
        # Add special characteristics based on condition and fuel type
        if self.fuel_type == self.FUEL_DIESEL:
            # Add diesel knock characteristic
            # This creates periodic impacts at the firing frequency
            impact_interval = 1.0 / self.firing_freq
            impact_strength = 0.5 * base_amplitude
            
            for t in np.arange(0, duration, impact_interval):
                # Find closest time point
                idx = int(t * sample_rate)
                if idx < len(signal):
                    # Add an exponentially decaying impulse
                    decay_time = 0.002  # seconds
                    
                    # Time points relative to impact
                    rel_time = time_points[idx:] - time_points[idx]
                    
                    # Create decaying impulse
                    decay = impact_strength * np.exp(-rel_time / decay_time)
                    
                    # Add to signal, limited to len(signal)
                    max_len = min(len(decay), len(signal) - idx)
                    signal[idx:idx + max_len] += decay[:max_len]
        
        # Add fuel system irregularity if in that condition
        if self.condition == self.CONDITION_FUEL_SYSTEM:
            # Create irregular firing pattern by modulating the signal
            mod_freq = self.firing_freq / self.num_cylinders
            mod_depth = 0.3
            modulation = 1 + mod_depth * np.sin(2 * np.pi * mod_freq * time_points)
            
            # Apply modulation
            signal *= modulation
            
            # Add random misfires
            num_misfires = int(duration * self.firing_freq * 0.1)  # 10% misfire rate
            for _ in range(num_misfires):
                misfire_time = duration * np.random.random()
                idx = int(misfire_time * sample_rate)
                if idx < len(signal):
                    # Create a dip in amplitude around the misfire
                    width = int(0.05 * self.firing_freq * sample_rate)  # Width of dip
                    start = max(0, idx - width//2)
                    end = min(len(signal), idx + width//2)
                    signal[start:end] *= 0.3  # Reduce amplitude during misfire
        
        # Add ambient noise
        noise_level = 0.01 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 2  # More noise in abnormal conditions
        
        noise = noise_level * np.random.normal(0, 1, len(time_points))
        signal += noise
        
        return time_points, signal
