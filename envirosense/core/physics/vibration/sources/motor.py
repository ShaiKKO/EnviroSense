"""
Motor vibration source implementation.

This module provides the specific vibration modeling for electric motors,
including different condition states and their characteristic frequencies.
"""

import numpy as np
from typing import Tuple, List, Dict, Optional, Any, Union
import math

from envirosense.core.physics.coordinates import Vector3D
from envirosense.core.physics.vibration.base import VibrationSource


class MotorVibration(VibrationSource):
    """
    Models vibration patterns generated by electric motors.
    
    This class models the specific vibration characteristics of electric motors,
    including their fundamental frequencies (typically related to RPM) and harmonics,
    as well as different operating conditions and fault patterns.
    """
    
    # Operating condition constants
    CONDITION_NORMAL = "normal"
    CONDITION_UNBALANCED = "unbalanced"
    CONDITION_BEARING_WEAR = "bearing_wear"
    CONDITION_MISALIGNMENT = "misalignment"
    CONDITION_LOOSE_MOUNTING = "loose_mounting"
    
    def __init__(self, 
                 name: str, 
                 position: Union[Vector3D, Tuple[float, float, float]],
                 power_rating: float = 10e3,  # 10 kW default
                 rpm: float = 1800.0,
                 condition: str = CONDITION_NORMAL,
                 source_id: Optional[str] = None):
        """
        Initialize motor vibration source.
        
        Args:
            name: Motor name
            position: Position in 3D space
            power_rating: Power rating in watts
            rpm: Motor speed in revolutions per minute
            condition: Operating condition of the motor
            source_id: Optional unique identifier
        """
        super().__init__(name, position, source_id)
        
        self.power_rating = power_rating
        self.rpm = rpm
        self.condition = condition
        self.load_factor = 1.0  # Default to full load
        
        # Calculate fundamental frequency (rotation frequency)
        self.rotation_freq = rpm / 60.0  # Hz
        
        # Store additional parameters in metadata
        self.metadata.update({
            "power_rating": power_rating,
            "rpm": rpm,
            "rotation_freq": self.rotation_freq,
            "condition": condition,
            "load_factor": self.load_factor
        })
    
    def set_load_factor(self, load_factor: float) -> None:
        """
        Set the current load factor (0.0 to 1.0+).
        
        Args:
            load_factor: Current load as fraction of rated capacity (1.0 = full load)
        """
        self.load_factor = max(0.0, load_factor)
        self.metadata["load_factor"] = self.load_factor
    
    def set_condition(self, condition: str) -> None:
        """
        Set the operating condition.
        
        Args:
            condition: One of the CONDITION_* constants
        """
        self.condition = condition
        self.metadata["condition"] = condition
    
    def set_rpm(self, rpm: float) -> None:
        """
        Set the motor speed in RPM.
        
        Args:
            rpm: Speed in revolutions per minute
        """
        self.rpm = rpm
        self.rotation_freq = rpm / 60.0  # Hz
        self.metadata["rpm"] = rpm
        self.metadata["rotation_freq"] = self.rotation_freq
    
    def _get_characteristic_frequencies(self) -> Dict[str, float]:
        """
        Calculate characteristic frequencies for this motor.
        
        These are frequencies of interest for monitoring motor health.
        
        Returns:
            Dictionary of named frequencies in Hz
        """
        # Rotation frequency (1x)
        f_rotation = self.rotation_freq
        
        # Line frequency (typically 50 or 60 Hz)
        f_line = 60.0  # Assuming 60 Hz power system
        
        # Number of poles (estimate based on typical 4-pole motors at 1800 RPM)
        # RPM = 120 * f_line / num_poles
        estimated_poles = round(120 * f_line / self.rpm)
        if estimated_poles < 2:
            estimated_poles = 2
        
        # Synchronous frequency
        f_sync = f_line * 2 / estimated_poles
        
        # Slip frequency (for induction motors)
        # Estimate 3% slip at full load as a typical value
        slip = 0.03
        f_slip = f_sync * slip
        
        # Electrical frequency in rotor
        f_electrical = estimated_poles * f_rotation / 2
        
        # Bearing characteristics (simplified model)
        # Assume a typical deep groove ball bearing
        num_balls = 10  # Typical number
        ball_diameter = 0.05  # Simplified model
        pitch_diameter = 0.15  # Simplified model
        contact_angle = 0  # Simplified model, radial load only
        
        # Bearing defect frequencies as multipliers of rotation frequency
        # Ball pass frequency outer race
        bpfo = num_balls * f_rotation / 2 * (1 - ball_diameter * math.cos(contact_angle) / pitch_diameter)
        
        # Ball pass frequency inner race
        bpfi = num_balls * f_rotation / 2 * (1 + ball_diameter * math.cos(contact_angle) / pitch_diameter)
        
        # Ball spin frequency
        bsf = pitch_diameter * f_rotation / (2 * ball_diameter) * (1 - (ball_diameter / pitch_diameter * math.cos(contact_angle))**2)
        
        # Fundamental train frequency (cage speed)
        ftf = f_rotation / 2 * (1 - ball_diameter * math.cos(contact_angle) / pitch_diameter)
        
        return {
            "rotation": f_rotation,
            "line": f_line,
            "sync": f_sync,
            "slip": f_slip,
            "electrical": f_electrical,
            "bpfo": bpfo,
            "bpfi": bpfi,
            "bsf": bsf,
            "ftf": ftf
        }
    
    def _get_frequency_components(self) -> Dict[float, float]:
        """
        Get frequency components and their relative amplitudes.
        
        Different operating conditions have different frequency patterns.
        
        Returns:
            Dictionary mapping frequency in Hz to relative amplitudes
        """
        # Get characteristic frequencies
        freqs = self._get_characteristic_frequencies()
        
        # Base components present in all motors
        components = {
            freqs["rotation"]: 1.0,            # 1x rotation frequency
            2 * freqs["rotation"]: 0.2,        # 2x rotation frequency
            freqs["line"]: 0.1,                # Line frequency
            2 * freqs["line"]: 0.05,           # 2x line frequency
            freqs["electrical"]: 0.3,          # Electrical frequency
            freqs["line"] - freqs["rotation"]: 0.05,  # Sidebands
            freqs["line"] + freqs["rotation"]: 0.05   # Sidebands
        }
        
        # Modify components based on condition
        if self.condition == self.CONDITION_UNBALANCED:
            # Unbalanced rotors show strong 1x component
            components[freqs["rotation"]] = 2.0
            
        elif self.condition == self.CONDITION_BEARING_WEAR:
            # Bearing damage shows up at characteristic frequencies
            components[freqs["bpfo"]] = 0.5
            components[freqs["bpfi"]] = 0.7
            components[freqs["bsf"]] = 0.4
            
            # Also add harmonics of these
            components[2 * freqs["bpfo"]] = 0.3
            components[2 * freqs["bpfi"]] = 0.4
            
            # Add modulation sidebands
            components[freqs["bpfi"] + freqs["rotation"]] = 0.2
            components[freqs["bpfi"] - freqs["rotation"]] = 0.2
            components[freqs["bpfo"] + freqs["rotation"]] = 0.15
            components[freqs["bpfo"] - freqs["rotation"]] = 0.15
            
            # High-frequency energy increase
            for i in range(3, 10):
                high_freq = i * 1000
                components[high_freq] = 0.05
            
        elif self.condition == self.CONDITION_MISALIGNMENT:
            # Misalignment typically shows up at 2x rotation frequency
            components[2 * freqs["rotation"]] = 1.0
            
            # Also increases axial vibration at 1x
            components[freqs["rotation"]] = 1.2
            
            # Can also show up at 3x
            components[3 * freqs["rotation"]] = 0.5
            
        elif self.condition == self.CONDITION_LOOSE_MOUNTING:
            # Loose mountings show sub-harmonic and non-integer harmonics
            components[0.5 * freqs["rotation"]] = 0.4
            components[1.5 * freqs["rotation"]] = 0.6
            components[2.5 * freqs["rotation"]] = 0.3
            
            # Also increases overall levels
            components[freqs["rotation"]] = 1.3
            components[2 * freqs["rotation"]] = 0.7
            
            # Often shows up as general noise increase
            for i in range(3, 10):
                components[i * freqs["rotation"]] = 0.2
        
        # Scale components based on load factor
        # Higher loads produce stronger vibrations
        for freq in list(components.keys()):
            if freq == freqs["rotation"]:
                # Fundamental frequency scales with load
                components[freq] *= (0.5 + 0.5 * self.load_factor)
            elif freq == 2 * freqs["rotation"]:
                # 2x frequency often increases more with load
                components[freq] *= (0.3 + 0.7 * self.load_factor)
            else:
                # Other frequencies scale with load
                components[freq] *= (0.7 + 0.3 * self.load_factor)
        
        return components
    
    def _calculate_base_amplitude(self) -> float:
        """
        Calculate the base amplitude based on motor size.
        
        Returns:
            Base vibration amplitude in m/sÂ²
        """
        # Base amplitude scales with power rating (larger motors vibrate more)
        # but not linearly (sqrt relationship as a simplified model)
        # Normalize to 10 kW
        power_factor = math.sqrt(self.power_rating / 10e3)
        
        # Base amplitude for a 10 kW motor at full load
        base_amp = 0.1  # m/sÂ²
        
        # Motors tend to vibrate more at higher speeds
        rpm_factor = self.rpm / 1800.0
        
        return base_amp * power_factor * rpm_factor
    
    def generate_spectrum(self, freq_range: Tuple[float, float, int]) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate frequency spectrum for this motor.
        
        Args:
            freq_range: Tuple of (min_freq, max_freq, num_points)
            
        Returns:
            Tuple of (frequencies, amplitudes) arrays
        """
        min_freq, max_freq, num_points = freq_range
        
        # Generate frequency array
        frequencies = np.linspace(min_freq, max_freq, num_points)
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Initialize amplitudes array
        amplitudes = np.zeros_like(frequencies)
        
        # For each component, add a peak at the corresponding frequency
        for component_freq, relative_amp in components.items():
            # Skip if outside frequency range
            if component_freq < min_freq or component_freq > max_freq:
                continue
            
            # Create a peak around the component frequency
            peak_width = 0.02 * component_freq  # Width of peak proportional to frequency
            
            # Calculate distance of all frequency points from this component
            dist_from_component = np.abs(frequencies - component_freq)
            
            # Create Gaussian-like peak around the component
            peak = base_amplitude * relative_amp * np.exp(-(dist_from_component / peak_width) ** 2)
            
            # Add to total amplitude
            amplitudes += peak
        
        # Add ambient noise floor (white noise)
        noise_level = 0.002  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 3  # More noise in abnormal conditions
        
        noise = noise_level * np.random.random(len(frequencies))
        amplitudes += noise
        
        return frequencies, amplitudes
    
    def generate_time_signal(self, duration: float, sample_rate: Optional[float] = None) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate time-domain signal for this motor.
        
        Args:
            duration: Signal duration in seconds
            sample_rate: Sample rate in Hz, defaults to 10x max expected frequency
            
        Returns:
            Tuple of (time_points, amplitude) arrays
        """
        # If no sample rate provided, use 10x a reasonable max frequency
        if sample_rate is None:
            # Use 10 kHz as a reasonable default for most motor vibrations
            sample_rate = 10000
        
        # Generate time points
        num_samples = int(duration * sample_rate)
        time_points = np.linspace(0, duration, num_samples)
        
        # Get frequency components
        components = self._get_frequency_components()
        
        # Get base amplitude
        base_amplitude = self._calculate_base_amplitude()
        
        # Initialize signal
        signal = np.zeros_like(time_points)
        
        # Add each frequency component to the signal
        for component_freq, relative_amp in components.items():
            # Skip frequencies above Nyquist frequency
            if component_freq > sample_rate / 2:
                continue
                
            # Component amplitude
            component_amp = base_amplitude * relative_amp
            
            # Generate component signal (sine wave)
            # Add random phase shift for realism
            phase_shift = 2 * np.pi * np.random.random()
            component = component_amp * np.sin(2 * np.pi * component_freq * time_points + phase_shift)
            
            # Add to total signal
            signal += component
        
        # Add special characteristics based on condition
        if self.condition == self.CONDITION_BEARING_WEAR:
            # Add impulsive content characteristic of bearing problems
            # This creates periodic impacts
            impact_freq = components.get(self._get_characteristic_frequencies()["bpfi"], 10)
            impact_interval = 1.0 / impact_freq
            
            for t in np.arange(0, duration, impact_interval):
                # Find closest time point
                idx = int(t * sample_rate)
                if idx < len(signal):
                    # Add an exponentially decaying sinusoid
                    decay_time = 0.01  # seconds
                    decay_freq = 2000  # Hz
                    
                    # Time points relative to impact
                    rel_time = time_points[idx:] - time_points[idx]
                    
                    # Create decaying sinusoid
                    decay = 0.5 * base_amplitude * np.exp(-rel_time / decay_time) * np.sin(2 * np.pi * decay_freq * rel_time)
                    
                    # Add to signal, limited to len(signal)
                    signal[idx:idx + len(decay)] += decay[:len(signal) - idx]
        
        # Add amplitude modulation if unbalanced
        if self.condition == self.CONDITION_UNBALANCED:
            # Add amplitude modulation at rotation frequency
            mod_depth = 0.3
            modulation = 1 + mod_depth * np.sin(2 * np.pi * self._get_characteristic_frequencies()["rotation"] * time_points)
            signal *= modulation
        
        # Add ambient noise
        noise_level = 0.005 * base_amplitude  # Base noise level
        if self.condition != self.CONDITION_NORMAL:
            noise_level *= 2  # More noise in abnormal conditions
        
        noise = noise_level * np.random.normal(0, 1, len(time_points))
        signal += noise
        
        return time_points, signal
